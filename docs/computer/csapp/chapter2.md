# **信息的表示和处理**

> [!tip] 本章节讲述了计算机存储数字与字符的方法（包括各种整型，无符号数，浮点数等），也讲述推导了相关运算以及其满足的性质

现代计算机用二进制来表示存储信息，称为位（bit），本章节主要介绍三种数字表示：无符号编码，补码编码，浮点数编码

> [!note] 计算机表示法是用有限的位来表示一个数字，这样会导致一些“溢出”和“精确度”的问题，就算是这样，整数运算以及其他数字运算仍然满足某些数学定理，浮点数是其中比较特殊的一类，和整数不同，整数范围比较小但是精确，浮点数范围大但是不精确

> Java语言创造了一套新的数字运算和表示标准，C/C++在数字表示和运算上有多种形式（具体取决于机器类型），但是Java对其有严格的标准

---

## 信息存储

- 计算机大多使用八位的“块”，称为“字节”，来作为最小的可寻址的内存单位
- 机器程序将内存视为一个巨大的字节数组，称为“虚拟内存”，每个字节有唯一的内存地址，它们构成了“虚拟地址空间”
- 每个字节对象可以简单地视为一个字节块，而程序本身就是一个字节序列

### 十六进制表示法

一个字节由八位组成，二进制表示冗长，十进制与二进制转换麻烦，所以可以使用十六进制数来表示位模式，由‘0’-‘9’以及‘A’-‘F’来表示。

> [!tip] 十六进制二进制转化：
>
> - 二进制数据拆成四个一组，最高位组不足四个则用0补齐
> - 将每一组转换为十六进制数
> - 十六进制转换二进制同理

### 字数据大小

每台计算机都有**字长**，标明指针数据的大小，也是虚拟地址的取值范围（现在的64位机器，32位机器），虚拟地址范围为：$$[0，2^w-1(w为字长)]$$

> 事实上，大多数64位机器也可以兼容32位程序，这是一种向后兼容，而且现在很多编译器也可以指定以哪种字长编译
>
> 从基本数据类型来看，这两种字长最大的区别在于long类型是4字节还是8字节（以及char*类型）

### 寻址和字节顺序

- 几乎在所有机器中，多字节对象被存储为连续的字节序列，对象地址为所使用的字节中最小的地址
- 某些机器在内存中按照从最低有效字节到最高有效字节进行存储，称为“小端法”，而另一种反过来的表示方法称为“大端法”
- 大多数Intel兼容机使用小端法，许多新的微处理器是“双端法”，但是一旦选择了特定操作系统，字节顺序也就固定了
- 对于大多数应用程序员，字节顺序不可见，特别的是，在网络应用程序的代码方面必须遵守已建立的关于字节顺序的规则

### 表示字符串

C语言中字符串被表示成一个以null结尾的字符数组，Java语言使用Unicode编码字符串

### 表示代码

相同的代码，在不同的机器（操作系统）上编译结果是不一样的，由于指令不兼容，编码方式不同，导致二进制代码不兼容

### 布尔代数简介

其中位向量一个很有用的应用就是表示有限集合，|和&对应于并和交，所以可以用来对集合编码

### C语言中的位级运算

&（and），|（or），^（异或），~（not）

一个常见用法是实现掩码运算

### C语言中的逻辑运算

&&，||，！

> [!attention] 注意与按位运算区分

### C语言中的移位运算

注意区分逻辑右移和算术右移，左移只有一种，C/C++里面大部分用算术右移，Java中可以由程序员指定

---



## 整数表示

整数编码有两种方式：无符号和有符号

### 整型数据类型

32位程序：

![20180326064340173](https://s2.loli.net/2022/07/19/jzQxvi6DTuaNILE.jpg)

64位程序：

![v2-e03fde0d3ab0c4b360ca7647878a7f80_r](https://s2.loli.net/2022/07/19/cByjCoYXgEzt5Wh.jpg)

可以看到，主要区别在于long类型（当然还有指针类型）大小范围不一样

C语言整型数据类型的保证的取值范围，C语言标准要求这些数据类型必须至少具有这样的取值范围：

![2018032606472465](https://s2.loli.net/2022/07/19/OqQFpLDVwyr8Tm5.jpg)

除了固定大小的数据类型，可以看出来，C语言要求正数与负数范围对称

> [!note] C/C++都支持有符号数和无符号数，Java不支持无符号数

### 无符号数的编码

假设有w位，将其看作是一个二进制数，就得到了无符号表示

所以无符号数的范围是：$$[0 - 2^w-1]$$ 

**无符号数编码具有唯一性**

### 补码编码

**计算机表示有符号数最常见的形式**

> 在补码定义中，字的最高位解释为负权值，同时最高位也被称为符号位，为1的时候是负数，为0时是正数

所以，w位补码表示有符号数的范围是：$$[-2^{w-1},2^{w-1}-1]$$

同时，与无符号数一样，**补码编码具有唯一性**

> [!attention] 补码表示的正负数范围不一致，这是导致程序出bug的一大原因，平时应注意

> Java语言中的标准很明确，对整数采用补码表示，这是为了Java的跨平台特性和可移植性

关于“原码和反码”，由于这两种表示方式会导致有+0与-0之分，现在大多数机器都采用补码表示整数，反码唯一不同点是最高位权值比补码少一

### 有符号数与无符号数之间的转换

原则是：数值可能改变，但是位值不变（位模式不变），下面的图表示了转换中数值的变化：

![12](https://s2.loli.net/2022/07/19/jC1UWf9GMcDqXgb.png)

### C语言中的有符号数与无符号数

当C语言执行一个运算时，一个数是有符号，另一个是无符号数，那么会隐式地将有符号数转换为无符号数（在进行<和>比较时，可能会产生问题）

### 拓展一个数字的位表示

- 无符号数的零拓展：在表示的开头添加零即可
- 补码数的符号拓展：在表示的开头添加原数最高有效位的值（这样会让补码数保持原有的数值）

### 截断数字

当计算机将w位数字截断为k位数字时，会直接丢弃高w-k位，截断一个数很可能会改变它的值，在这个例子中表现为对2的k次方取模

### 有符号数与无符号数的建议

**建议不使用或者减少使用无符号数！！！**

---

## 整数运算

### 无符号加法

数字相加可能会导致字长增长，某些语言支持无限精度运算，但是一般情况下，大部分语言支持**固定精度**运算

> 无符号数加法会将操作数超过字长的部分截断丢弃

> [!tip] 加法溢出检测：假设0<=x,y<=UMax,令s=x+y，当且仅当s<x(或者s<y)时溢出

对于无符号数的逆元：当x=0时，逆元为0，x>0时，逆元：$2^w-x（w为字长）$

### 补码加法

对于$-2^{w-1}<=x,y<=2^{w-1}-1$其和表示为：

| 和          | 范围                     | 备注   |
| ----------- | ------------------------ | ------ |
| $x+y-2^w$   | $2^{w-1}<=x+y$           | 正溢出 |
| $x+y$       | $-2^{w-1}<=x+y<=2^{w-1}$ | 正常   |
| $x+y+2^{w}$ | $x+y<-2^{w-1}$           | 负溢出 |

两个数的补码之和与无符号之和有相同的位级表示

> [!tip] 检测补码加法溢出：假设TMin<=x,y<=TMax,令s=x+y，当且仅当x>0,y>0但s<=0时，发生了正溢出，当且仅当x<0,y<0,s>=0时，发生了负溢出

### 补码的非

补码表示下，每个数字都有其加法逆元，仅当x为TMin时，逆元也为TMin，其他情况下，逆元为-x

### 无符号乘法

同加法一样，如果结果太大，会导致积被截断（效果上等同于%$2^w$）

### 补码乘法

补码乘法与无符号乘法在位级表示上是一样的，可以理解为将乘积转换为无符号数，然后对$2^w$取模，再转换为有符号数

### 乘以常数

在大多数机器上，乘法运算相当慢，编译器会试图使用移位和加法来代替乘法，实现程序的优化

- 对于乘以2的幂：将原操作数左移得到结果（不管是无符号数还是补码，结果都一样）
- 对于其他乘法：比如x乘以14，利用$14=2^3+2^2+2^1$,编译器会将其优化为(x<<3)+(x<<2)+(x<<1),但是实际上也可能分解为很多组移位，编译器一般在只需要少量移位，加减法的时候才会考虑这种优化

### 除以2的幂

- 在大多数机器上，整数除法比整数乘法更慢

- 通常采用右移来实现，无符号数采用逻辑右移，有符号数采用算术右移

- 整数除法总是舍入到零

- 对于除以2的幂的补码除法，为了使负数向上舍入，需要在算术右移之前加上适当的偏置：通过$(x+(1<<k)-1)>>k来得到x/2^k$,

### 关于整数运算的最后思考

计算机执行的“整数”运算实际上是一种模运算形式，无符号数与补码在某些方面的不一致导致了程序的很多bug，当然，因为计算机表示整数都有精度限制，所以一些溢出也可能导致令人困惑的bug

---

## 浮点数

计算机对浮点数编码方式形如：$V=x*2^y$,IEEE推出了浮点数标准

### 二进制小数

表示方法如下：$\sum_{i=-n}^m2^i*b_i$

当然，在考虑有限长度的编码条件下，并不能精确地表示所有有理数，增加长度可以提升精度

### IEEE浮点数表示

IEEE浮点数标准采用$V=(-1)^s*M*2^E$来表示一个数

- 符号：s决定数值的正负（s=1，负；s=0，正）
- 尾数：M为一个二进制小数，范围是[1,2),或者[0,1)
- 阶码：E用于对浮点数加权，将浮点数位划分为三个字段：
  - 一个单独的符号位s
  - k位的阶码字段$exp=e_{k-1}···e_1e_0$编码阶码E
  - n位小数字段$frac=f_{n-1}···f_1f_0$编码尾数M，依赖于阶码是否为零

在两种浮点数类型中，三个字段分配的长度不一：

![20200609094239801](https://s2.loli.net/2022/07/21/VxX3voe5yhfDLCr.png)

给定位表示后，根据exp值，浮点数可以分为三种情况四个值（其实是五个值）：

![20210629160426828](https://s2.loli.net/2022/07/21/ThsSbgvI4F27Xqd.png)

1. 规格化的值：

当exp数值不全为零而且不全为1时，这种情况下，阶码字段被解释为偏置形式表示有符号整数，即$E=e-bias$,bias等于$2^{k-1}-1$(单精度为127，双精度为1023)

小数字段frac被解释为小数值f(0<=f<1),二进制小数点在最高位的左边，尾数定义为M=1+f

2. 非规格化的值

阶码全为0时，这种情况下，阶码值E=1-bias，而尾数值是M=f，不包含开头的1

非规格化数值可以表示数值0，虽然有正负0之分

非规格化数值也可以表示非常接近0的数，它提供了一种属性：逐渐溢出，让数值均匀地接近0.0

3. 特殊值

阶码全为1时，当小数域为0时，表示的数为无穷，符号由s决定，无穷用来表示溢出的结果，当小数域非0时，表示NaN

### 数字示例

![v2-2e5f1cad621f85df33d1cc0ac9f60f4f_r](https://s2.loli.net/2022/07/21/MkURpi87n6wDjlB.jpg)

![floating_point_number_float8_example](https://s2.loli.net/2022/07/21/XySaKbZ52hOsjIw.gif)

最大非规格化数7/512与最小规格化数8/512的平滑转变归功于E的定义

![12859527-739f31e94fc73c7b](https://s2.loli.net/2022/07/21/wHDmxWbhXO7ksCc.png)

### 舍入

表示方法限制了浮点数的范围和精度，所以浮点数只能近似的表示实数运算

一般有四种舍入方式：向偶数舍入是默认方式：

![12859527-af37f27e78ac23a9](https://s2.loli.net/2022/07/21/8sBaSfjUTuqWQAo.png)

向偶数舍入避免了产生平均值的统计误差

### 浮点运算

IEEE标准指定将浮点数x，y看作实数，计算结果取某个精度的舍入结果，实数加法也可以形成阿贝尔群，事实上，对于x和y，运算可交换，但是运算不可以结合，原因是浮点数是不精确的表示，运算也是不精确的运算！

但是，浮点数加法满足单调性属性，这是无符号或者补码加法不满足的性质

同时，浮点数也不满足乘法分配律

### C语言中的浮点数

C标准并未规定使用IEEE浮点数标准，这些机器大多使用两种浮点数类型，运用向偶数舍入的方式，所以机器无法使用标准的方法改变舍入规则或者得到特殊值

---



## 小结

-  计算机将信息编码为比特，通常组织成字节序列
- 大多数机器对整数使用补码编码，对浮点数使用IEEE标准754编码
- 无符号数与有符号数进行类型转换时，遵循底层位模式不变
- 由于编码长度有限，整数运算超出范围会导致溢出，同时，浮点数非常接近0时，直到转换成0，也会下溢
- 无符号数和补码的运算都遵循整数运算的很多性质，包括结合律，交换律，分配律，从而允许编译器做出很多优化
- 使用浮点数运算必须非常小心，因为浮点数只有有限范围和精度，并且不遵循某些运算规律，比如结合性
