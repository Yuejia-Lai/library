# 程序的机器级表示

> [!tip] 本章主要讲解了**汇编代码**以及计算机中的相关概念，对整个程序的编译过程以及编译器有一个整体的认识，让我们对计算机底层原理有更深入的了解，便于之后进行代码效率优化以及一些令人“困惑”的bug

本章节内容基于x86-64，在不同的机器上可能有细微的差别，从浏览C语言，汇编语言，机器语言之间的关系，了解x86-64的细节。之后是数据的表示以及控制结构，再到过程的实现，然后是数组，结构体等数据结构的实现，最后介绍一些内存越界和系统缓存区溢出攻击的问题，还有一些GDB调试器检查机器级程序的技巧，以及浮点数类型数据的操作代码示例

## 历史观点

Intel处理器系列俗称x86，经历了一个长期的演化过程，列举一些intel处理器模型名称：

|        8086         |        80286         |        i386         |
| :-----------------: | :------------------: | :-----------------: |
|        i486         |       Pentium        |     PentiumPro      |
|     Pentium/MMX     |      Pentium II      |     Pentium III     |
|      Pentium 4      |      Pentium 4E      |       Core 2        |
| Core i7(781M晶体管) | Core i7(1.17G晶体管) | Core i7(1.4G晶体管) |

每个后继者处理器的设计都是向后兼容的，较早版本编译的代码可以在新处理器上运行

> 摩尔定律：芯片上的晶体管数量每年翻一番

---

## 程序编码

一个C程序有两个文件：p1.c和p2.c，用Unix命令编译：

```bash
gcc -Og -o p p1.c p2.c
```

-Og为优化等级，gcc为GCC的C编译器

### 机器级代码

对于机器级编程有两种重要抽象：

- 指令集体系结构/指令集架构
- 使用虚拟地址代替内存地址

**汇编代码的特点是用可读性更改好的文本格式表示**

> 在x86-64机器代码中，隐藏的处理器状态都是可见的：
>
> - 程序计数器：（%rip）表示下一条指令在内存中的地址
> - 整数寄存器文件：16个命名的位置，可以存储64位值，有的存储整数或者地址数据，有的记录程序状态，有些用于保存临时数据
> - 条件码寄存器：保存最近执行的算术或者逻辑指令的状态信息
> - 一组向量寄存器：存放一个或者多个整数或者浮点数值

一般来说，程序内存包含：程序可执行文件机器代码，操作系统需要的信息，管理过程调用和返回时的运行时栈，用户分配的内存块等，**操作系统负责将虚拟地址翻译成实际地址**，一条机器指令只执行一个非常基本的操作

### 代码示例

假设我们写了一个 C 语言代码文件 **mstore.c**，包含如下的函数定义：

```c
long mult2(long, long);
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

在命令行上使用 “-S” 选项，就能看到 C 语言编译器产生的汇编代码：

```bash
linux> gcc -Og -S mstore.c
```

这会使 GCC 运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。

汇编代码文件包含各种声明，包括下面几行：

```
multstore:
  pushq   %rbx
  movq    %rdx, %rbx
  call    mult2
  movq    %rax, (%rbx)
  popq    %rbx
  ret     
```

上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq 指令表示应该将寄存器％rbx 的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。

如果我们使用 “-c” 命令行选项，GCC 会编译并汇编该代码：

```bash
linux> gcc -Og -c mstore.c
```

这就会产生目标代码文件 mstore.o，它是二进制格式的，所以无法直接查看。1368 字节的文件 mstore.o 中有一段 14 字节的序列，它的十六进制表示为：

53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3

这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知

要査看机器代码文件的内容，有一类称为反汇编器（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux 系统中，带 ‘-d’ 命令行标志的程序 OBJDUMP（表示 “object dump”）可以充当这个角色：

```bash
linux> objdump -d mstore.o
```

结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）：

```
# Disassembly of function sum in binary file mstore.o
0000000000000000 <multstore>:
----------------------------------------------------------
Offset   Bytes                Equivalent assembly language
----------------------------------------------------------
    0:   53                   push   %rbx
    1:   48 89 d3             mov    %rdx,%rbx
    4:   e8 00 00 00 00       callq  9 <multstore+0x9>
    9:   48 89 03             mov    %rax,(%rbx)
    c:   5b                   pop    %rbx
    d:   c3                   retq
```

在左边，我们看到按照前面给出的字节顺序排列的 14 个十六进制字节值，它们分成了若干组，每组有 1 ~ 5 个字节。每组都是一条指令，右边是等价的汇编语言。

其中一些关于机器代码和它的反汇编表示的特性值得注意：

- x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 **pushq %rbx** 是以字节值 53 开头的。
- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的 ‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了 ‘q’ 后缀，同样，省略这些后缀也没有问题。

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main 函数。假设在文件 main.c 中有下面这样的函数：

```c
#include <stdio.h>

void multstore(long, long, long *);

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}

long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

然后，我们用如下方法生成可执行文件 prog：

```bash
linux> gcc -Og -o prog main.c mstore.c
```

文件 prog 变成了 8655 个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。我们也可以反汇编 prog 文件：

```bash
linux> objdump -d prog
```

反汇编器会抽取出各种代码序列，包括下面这段：

```
# Disassembly of function sum in binary file prog
----------------------------------------------------------
Offset    Bytes                 Equivalent assembly language
----------------------------------------------------------
0000000000400540 <multstore>:
400540:   53                    push   %rbx
400541:   48 89 d3              mov    %rdx,%rbx
400544:   e8 42 00 00 00        callq  40058b <mult2>
400549:   48 89 03              mov    %rax,(%rbx)
40054c:   5b                    pop    %rbx
40054d:   c3                    retq
40054e:   90                    nop
40054f:   90                    nop
```

这段代码与 mstore.c 反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同一链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同之处在于链接器填上了 callq 指令调用函数 mult2 需要使用的地址（反汇编代码第 4 行）。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了两行代码（第 8 和 9 行）。这两条指令对程序没有影响，因为它们出现在返回指令后面（第 7 行）。插入这些指令是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能更好地放置下一个代码块。

### 关于格式的注解

GCC 产生的汇编代码对我们来说有点儿难读。一方面，它包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。例如，假设我们用如下命令生成文件 mstore.s

```
        .file   "010-mstore.c"
        .text
        .globl  multstore
        .type   multstore, @function
multstore:
        pushq   %rbx
        movq    %rdx, %rbx
        call    mult2
        movq    %rax, (%rbx)
        popq    %rbx
        ret
        .size   multstore, .-multstore
        .ident  "GCC: (Ubuntu 4.8.1-2ubuntu1~12.04) 4.8.1"
        .section        .note.GNU-stack,"",@progbits
```

所有以 ‘**.**’ 开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。

为了更清楚地说明汇编代码，我们用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于我们的示例，带解释的汇编代码如下：

```
# void multstore(long x, long y, long *dest)
# x in %rdi, y in %rsi, dest in %rdx
multstore:
  pushq     %rbx                # Save %rbx
  movq      %rdx, %rbx          # Copy dest to %rbx
  call      mult2               # Call mult2(x, y)
  movq      %rax, (%rbx)        # Store result at *dest
  popq      %rbx                # Restore %rbx
  ret                           # Return
```

---



## 访问信息

一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针

![整数寄存器-d065d9434921462faf17f0810aa9e885](https://s2.loli.net/2022/07/25/CraQh9kZpVl1iKR.png)

指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作

字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器

对于生成小于 8 字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为 0

其中最特别的是栈指针 %rsp，用来指明运行时栈的结束位置

### 操作数指示符

各种不同的操作数的可能性被分为三种类型：

- 第一种类型是**立即数**（immediate），用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是 ‘$’ 后面跟一个用标准 C 表示法表示的整数，比如，$-577 或 $0x1F。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。
- 第二种类型是**寄存器**（register），它表示某个寄存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节数分别对应于 8 位、16 位、32 位或 64 位。在图 3-3 中，我们用符号 ra\rm r_ara 来表示任意寄存器 a，用引用R[ra]\rm R[r_a]R[ra]来表示它的值，这是将寄存器集合看成一个数组 R，用寄存器标识符作为索引。
- 第三类操作数是**内存引用**，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号$M_b[Addr]$表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，我们通常省去下标 b。

有多种不同的**寻址模式**，允许不同形式的内存引用。表中底部用语法 $Imm(r_b,r_i,s)$表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移 Imm，一个基址寄存器$r_b$，一个变址寄存器$r_i$，和一个比例因子 s，这里 s 必须是 1、2、4 或者 8. 基址和变址寄存器都必须是 64 位寄存器。有效地址被计算为$Imm  +R[r_b]+R[r_i] \cdot s$。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况

![24](https://s2.loli.net/2022/07/25/d1EsUBAH9a4IZvq.png)

### 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令

在我们的讲述中，把许多不同的指令划分成**指令类**，每一类中的指令执行相同的操作，只不过操作数大小不同

![25](https://s2.loli.net/2022/07/25/3jY1RXSVzBkOKEi.png)

源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址

**X86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置**

> [!note] 大多数情况中，MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是 movl 指令以寄存器作为目的时，它会把该寄存器的高位 4 字节设置为 0

movabsq 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的

下图记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ 类中的指令把目的中剩余的字节填充为 0，而 MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4 个的情况，当然只考虑目的大于源的情况

![Snipaste_2022-07-25_21-42-41](https://s2.loli.net/2022/07/25/fh9LT24t7JawbVC.png)

![sign-extand](https://s2.loli.net/2022/07/25/V3XKxM9pCThut2Z.png)

### 数据传送示例

略

### 压入与弹出栈数据

![26](https://s2.loli.net/2022/07/25/Ji2Hd4cUgbYqpRV.png)

- 栈向低地址方向增长（一般减8）；
- `push` 和 `pop` 可以由相应的移动和算数指令来实现，但前者的编码仅需要**一个字节**；
- `pop` 只会影响 %rsp 的值，而不会实际清除栈中存放的数据（后续会被覆盖）

## 算术和逻辑操作

![27](https://s2.loli.net/2022/07/25/7YG3ZkLWQHJArOm.png)

- 除加载有效地址指令 `leaq` 外的其他指令均**有对应不同操作数大小的变种**，如 `addb`、`addw` 等；

### 加载有效地址

`leaq` 也可被用于与“加载有效地址”无关的操作，比如“**简单算数操作**”，但不会改变 rflags 寄存器的状态；

本来是用于将有效地址写入目的操作数，而且目标操作数必须是寄存器，也可以执行简单的加法和有限形式的乘法

### 一元和二元操作

一元操作只有一个操作数，既是源又是目的，这个操作数可以是寄存器或者内存位置

二元操作的第一个操作数可以是立即数、寄存器或内存位置。第二个操作数可以是寄存器或内存位置，第二个操作数既是源又是目的

### 移位操作

移位操作的移位量可以是一个立即数，或者放在单字节寄存器 **%cl** 中。后者的有效移位量是由其低 m 位决定的，而 $2^m = w$（w 为数据位长，比如 `salb` 对应的 8 位，`salw` 对应的 16 位等）

右移指令有算术右移和逻辑右移

### 特殊的算数操作

![28](https://s2.loli.net/2022/07/25/XYMhJjLr8Vf4GKI.png)

- `imulq` 指令有两种不同的形式。第一种为**双**操作数，**不区分符号**，用于从两个 64 位操作数中产生一个 64 位的乘积（阶段后位模式相同）；另一种为**单**操作数，**区分符号**，用于计算两个 64 位值的“**全 128 位乘积**”，要求一个参数必须在 **%rax** 中，结果分别放置在 **%rdx**（高位）与 **%rax**（低位）中；
- 类似单操作数乘法，有符号除法指令 `idivq` 将寄存器 **%rdx**（高 64 位）与 **%rax**（低 64 位）联合组成的 128 位数作为**被除数**。除数作为操作数给出，结果的商存放在 %rax 中，余数存储在 %rdx 中。指令 `cqto` 可用于将 %rdx 填充为 %rax 的符号位（当仅需要 64 位被除数时）。无符号除法使用 `divq` 指令，寄存器 %rdx 会被事先设置为 0。注：其他的单操作数除法指令还有 `idiv` \ `idivl`。
